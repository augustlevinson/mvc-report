{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
<div class="main">
    <h1>Report</h1>
    <section id="kmom01">
        <a href="#kmom01"><h2>kmom01</h2></a>
        <h3 class="report-h3">
            Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.
        </h3>
        <p>
            Första introduktionen till objektorientering fick jag i javascriptkursen. Där snuddades det dock bara vid i förbifarten. I den nyss avslutade kursen oopython jobbade vi desto mer objektorienterat. Där dök vi ner i några olika datastrukturer och det blev snabbt tydligt att objektorienterad programmering är kraftfullt. Inkapslingen av funktioner och variabler skyddar dem från obehörig och oönskad manipulation. Dessutom blir det enklare att uppnå kod som följer DRY-principen, då återkommande funktionalitet kan utgöra egna objekt som kan användas på flera ställen.
        </p>
        <h3 class="report-h3">
            Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver veta/förstå för att kunna komma igång och skapa sina första klasser?
        </h3>
        <p>
            En klass är som en mall som man kan skapa objekt utifrån. Klassen definieras med olika variabler och metoder som är specifika för objekt av just den klassen. När man skapar ett objekt av en viss klass kallas det att man instansierar ett objekt av klassen. Istället för att jobba med publika variabler och metoder jobbar man mot objekt genom ett så kallat API, där man anropar objektets metoder och variabler. Detta avgränsar hur olika användare och program får jobba mot objektets innehåll.
        </p>
        <h3 class="report-h3">
            Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?
        </h3>
        <p>
            Jag tycker mappstrukturen känns väldigt stor för de projekt vi ska utföra, men samtidigt är det väl mer och mer så man bygger appar. Ju större app desto fler filer behövs och desto viktigare blir det med en bra struktur på dem. Så bra att vi vänjer oss vid det och skapar goda vanor. Ofta hjälper dessutom en pakethanterare som Composer eller NPM oss att sätta grunden för strukturen, så jättekrångligt är det nog inte ändå.
        </p>
        <h3 class="report-h3">
            Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla? Är det några särskilda områden som du känner att du vill veta mer om?
        </h3>
        <p>
            Jag prioriterade kapitel 4, Language Highlights. Där fick jag en snabb liten genomgång av språket och dess olika paradigmer, såsom objektorienterad och funktionell programmering och skillnaderna däremellan. Kapitlet länkar också en hel del till php.net för fördjupning om olika delar. Det känns som läsning som kan behöva återkommas till under kursen. Mer specifikt skulle jag gärna läsa på mer kring <a href="https://www.php.net/language.oop5">klasser och objekt</a>.
        </p>
        <h3 class="report-h3">TIL: Objekt och klasser fungerar hittills väldigt liknande i flera språk, även om syntaxen fungerar lite olika.</h3>
    </section>
    <section id="kmom02">
        <a href="#kmom02"><h2>kmom02</h2></a>
        <h3 class="report-h3">Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.</h3>
        <p>
            <strong>Arv</strong> innebär att en klass ärver funktionalitet från en annan klass. Den ärvande klassen kallas subklass och klassen den ärver ifrån kallas basklass. Det är användbart när vi vill utöka funktionaliteten för en klass men inte göra den för stor och komplicerad. Ett exempel på arv i min implementation av veckans kursmoment är DeckOfCardsWithJoker som är en subklass till DeckOfCards. Den gör samma sak som basklassen, med det lilla tillägget att kortleken även innehåller jokrar när objektet konstrueras.
        </p>
        <p>
            <strong>Komposition</strong> är när en klass använder sig av en annan klass. Ett exempel från detta kursmoment är DeckOfCards som använder ett objekt av klassen Card för varje kort i leken.
        </p>
        <p>
            <strong>Traits</strong> är kodsnuttar som kan användas av flera klasser utan att ärva. Det kan handla om en grundläggande konstruktion som behövs i flera klasser och som man inte vill behöva skriva för varje klass. Då kan det vara läge att istället generalisera konstruktionen och bryta ut den i ett trait.
        </p>
        <p>
            <strong>Interface</strong> är ett annat sätt att dela funktionalitet mellan klasser, eller i alla fall försäkra sig om att det går. När en klass använder interface ger den ett löfte om att den går att använda på ett visst sätt. Man kan alltså förvänta sig att det som definieras i interfacet går att använda i klassen. En fördel med detta är att man kan jobba med klasser som man inte har så bra koll på (om man t ex inte skrivit dem själv, vilket inte är ovanligt), så länge man har koll på ett interface som klassen “lovar” att fungera enligt.
        </p>
        <h3 class="report-h3">Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din kod och dina klasser?</h3>
        <p>
            Jag valde att utgå från klassen deckOfCards i min implementation. När en kortlek (deckOfCards) konstrueras populeras den med kortobjekt (Card) i stigande ordning. Routen Deck instansierar kortleksklassen och visar upp alla kort.
        </p>
        <p>
            När routen /shuffle anropas tar den en kopia av kortleken (om kortleken finns - annars skapas den) och blandar den. Därför ändras inte den ursprungliga kortlekens ordning och /deck går fint att navigera tillbaka till för att se korten i ordning igen. Routen /draw anropar drawNumber(1), ett kort dras och visas upp. Läggs ett tal till i slutet av routen enligt /draw<tal> anropas metoden med talet som argument, enligt drawNumber(<tal>). Det/de kort som dras tas också bort från kortleksobjektet.
        </p>
        <p>
            Jag är riktigt nöjd med resultatet och jag känner att jag lärt mig massor om objektorientering och PHP-syntax bara under detta kursmoment! Däremot har jag slarvat med att stanna upp och göra små git commits. Tycker det är svårt att inte bara köra på, men det blir ju inte ett så kul repo om man gör så. Skärpning!
        </p>
        <p>
            En potentiell förbättring hade varit att använda traits och interface. Det kanske får bli i kommande kursmoment?
        </p>
        <h3 class="report-h3">Vilka är dina reflektioner så här långt med att jobba i Symfony med applikationskod enligt MVC?</h3>
        <p>
            Det är ganska smidigt dela upp koden enligt MVC. Det blir tydligt vilken kod som gör vad. Även om det går att blanda hanterandet av logik och villkor både i klasserna, controllern och twigfilen försöker jag fördela det på ett vettigt sätt (till exempel att elementet med flashmeddelandet alltid ligger med i HTML:en, eftersom det inte syns förrän ett flashmeddelande genereras i controllern).
        </p>
        <p>
            Jag börjar dessutom tycka det är riktigt trevligt att jobba med Twig. Syntaxen är enkel när man väl får kläm på den.
        </p>
        <h3 class="report-h3">Vilken är din TIL för detta kmom?</h3>
        <p>
            Återanvänd twigfiler! När man ska lägga till en undersida på sajten har man ofta redan en fil med liknande struktur som det man vill uppnå. Kopiera och modifiera, det går snabbast! Kanske en no-brainer, men ändå?
        </p>
    </section>
    <section id="kmom03">
        <a href="#kmom03"><h2>kmom03</h2></a>
        <h3 class="report-h3">Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?</h3>
        <p>
            Jag bestämde mig för att lägga mycket tid på dessa inledande delar, enligt principen “measure twice, cut once”. Att först tvingas tänka igenom logiken några varv var nog bra. Det gav en överblick över vad det var som skulle implementeras. Detta underlättade sedan kodandet, då det mest handlade om att följa planen och försöka lösa logiken. Det kändes helt klart mer strukturerat än om jag hade hoppat rakt in i koden.
        </p>
        <h3 class="report-h3">Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din kod, dina klasser och applikationen som helhet?</h3>
        <p>
            Jag försökte så långt jag kunde att hålla routecontrollern kort och koncis. Detta genom att låta Game21-klassen stå för lejonparten av spellogiken. Varje kort är ett objekt av klassen Card. Kortleken och dess metoder utgörs av DeckOfCards, som populerar sig med objekt av Cardklassen. CardHand utgör spelarens och bankens respektive korthänder, som dras från kortleken och består av Cardobjekt. 
        </p>
        <p>
            Jag är hyfsat nöjd med resultatet, men inser att det finns en del punkter att förbättra. Game21 hade kunnat få fler metoder så att routern bara anropar den, exempelvis metoder för att initiera korthand och kortlek. Nu har controllern beroende av fyra klasser, om allt istället hade gått via Game21 hade det räckt med den som beroende.
        </p>
        <h3 class="report-h3">Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?</h3>
        <p>
            När allt väl är på plats är det ganska skönt att ha ett ramverk. Det är enklare att hämta variabler från klasserna och visa upp dem i en sida. Symfony erbjuder dessutom enklare debugging, vilket kan underlätta enormt vid felsökande.
        </p>
        <h3 class="report-h3">Vilken är din TIL för detta kmom?</h3>
        <p>
            Fördela ansvaret på klasserna. Om en klass gör en sak blir det enklare att ändra beteendet. Om en klass behöver något specifikt från en annan klass, skapa en metod för detta i den andra klassen. I takt med att klasserna och programmen växer kan man alltid generalisera metoder och istället tillåta fler parametrar för att uppnå samma specifika resultat.
        </p>
    </section>
    <section id="kmom04">
        <a href="#kmom04"><h2>kmom04</h2></a>
        <h3 class="report-h3">Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever PHPUnit rent allmänt.</h3>
        <p>
            Jag tyckte det var riktigt kul att skriva tester! PHPUnit skiljer sig inte så vansinnigt mycket från den testning vi gjorde i oopythonkursen. Där skrapade vi bara på ytan av enhetstestning, men nu i detta kursmoment känner jag verkligen att vi fick mycket på fötterna om hur och varför man testar. Då särskilt enhetstester med PHPUnit, men det var också bra att få en liten idé om hur olika faser och typer av tester kan se ut.
        </p>
        <h3 class="report-h3">Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?</h3>
        <p>
            Jag lyckades nå <strong>96.75%</strong> kodtäckning. Det är jag nöjd med! Det är några sista rader i Game21 som inte täcks.
        </p>
        <h3 class="report-h3">Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet?</h3>
        <p>
            Överlag tycker jag mina klasser består av testbar kod. Jag gjorde inga ändringar i koden för att öka testbarheten. Klassen som sköter spellogiken, Game21, hade dock kunnat delas upp bättre för att öka testbarheten. Metoder använder varandra, vilket gör att de i vissa fall testas via varandra. Där fick jag göra många olika tester, ofta med många olika steg i, för att få en god kodtäckning. Då Game21 är så beroende av andra klasser ville jag egentligen testa mockning i testerna för just den klassen, men tiden blev för knapp.
        </p>
        <h3 class="report-h3">Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.</h3>
        <p>
            Ja, det kan nog ofta vara sant. Jag tänker att ju mindre delkomponenter koden är uppdelad i desto lättare blir dessa att återanvända för att slippa upprepa sig. Därigenom torde det även bli lättare att isolera varje del och skriva tester som verkligen testar alla delar av kodens funktionalitet. Dessutom blir det ju lättare för en själv eller någon annan att få koll på vad olika delar av koden gör om den är inkapslad i många beståndsdelar som ansvarar för få saker.
        </p>
        <h3 class="report-h3">Vilken är din TIL för detta kmom?</h3>
        <p>
            Enhetstestning gör att man får syn på sin logik och eventuella brister i den, samtidigt som de är ganska enkla att definiera utifrån en kravspecifikation. Därför är det bra att sätta upp enhetstester från början och sedan bygger man kod som klarar dessa. Testdrivet, helt enkelt - det vill jag testa på!
        </p>
    </section>
    <section id="kmom05">
        <a href="#kmom05"><h2>kmom05</h2></a>
        <p>
            Report text here.
        </p>
    </section>
    <section id="kmom06">
        <a href="#kmom06"><h2>kmom06</h2></a>
        <p>
            Report text here.
        </p>
    </section>
    
</div>
{% endblock %}
